# =============================================================================
# Code2Cloud Infrastructure Setup
# =============================================================================
# This playbook handles:
#   1. Cloudflare DNS configuration
#   2. System preparation (firewall, packages)
#   3. K3s installation
#   4. Helm installation
#   5. Applying Kubernetes manifests
#   6. Building and deploying frontend/backend/worker images
#
# Usage:
#   ansible-playbook -i inventory.ini playbook.yml -e @secrets.yml
#   ansible-playbook -i inventory.ini playbook.yml -e @secrets.yml --tags dns
#   ansible-playbook -i inventory.ini playbook.yml -e @secrets.yml --tags build
#   ansible-playbook -i inventory.ini playbook.yml -e @secrets.yml --tags k8s
# =============================================================================

---
- name: Code2Cloud Infrastructure Setup
  hosts: k3s_server
  become: true
  gather_facts: true

  vars:
    kubeconfig_remote: /etc/rancher/k3s/k3s.yaml
    kubeconfig_dir: "{{ lookup('env', 'HOME') }}/kubeconfig"
    kubeconfig_local: "{{ lookup('env', 'HOME') }}/.kube/config"
    k8s_manifests_dir: "../k8s"
    build_workspace: /tmp/code2cloud-build
    registry_internal: "registry.registry.svc.cluster.local:5000"

  vars_files:
    - secrets.yml

  handlers:
    - name: Save iptables
      ansible.builtin.command: netfilter-persistent save

    - name: Restart k3s
      ansible.builtin.systemd:
        name: k3s
        state: restarted

  tasks:
    # =========================================================================
    # PHASE 0: CLOUDFLARE DNS CONFIGURATION
    # =========================================================================
    - name: Display deployment information
      ansible.builtin.pause:
        seconds: 1
        prompt: |
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          Target: {{ inventory_hostname }} ({{ ansible_host }})
          Domain: {{ domain }}
          Architecture: {{ ansible_architecture }}
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      tags: [always]

    - name: Configure Cloudflare DNS records
      block:
        - name: Create A record for main domain ({{ domain }})
          ansible.builtin.uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records"
            method: POST
            headers:
              Authorization: "Bearer {{ cloudflare_api_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              type: "A"
              name: "{{ domain }}"
              content: "{{ ansible_host }}"
              ttl: 300
              proxied: false
            status_code: [200, 400]
          register: dns_main
          delegate_to: localhost
          become: false

        - name: Create A record for API subdomain ({{ api_subdomain }}.{{ domain }})
          ansible.builtin.uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records"
            method: POST
            headers:
              Authorization: "Bearer {{ cloudflare_api_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              type: "A"
              name: "{{ api_subdomain }}.{{ domain }}"
              content: "{{ ansible_host }}"
              ttl: 300
              proxied: false
            status_code: [200, 400]
          register: dns_api
          delegate_to: localhost
          become: false

        - name: Create wildcard A record for preview apps (*.{{ deploy_wildcard }}.{{ domain }})
          ansible.builtin.uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records"
            method: POST
            headers:
              Authorization: "Bearer {{ cloudflare_api_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              type: "A"
              name: "*.{{ deploy_wildcard }}.{{ domain }}"
              content: "{{ ansible_host }}"
              ttl: 300
              proxied: false
            status_code: [200, 400]
          register: dns_wildcard
          delegate_to: localhost
          become: false

        - name: Display DNS configuration status
          ansible.builtin.pause:
            seconds: 1
            prompt: |
              DNS Records configured:
              - {{ domain }} â†’ {{ ansible_host }}
              - {{ api_subdomain }}.{{ domain }} â†’ {{ ansible_host }}
              - *.{{ deploy_wildcard }}.{{ domain }} â†’ {{ ansible_host }}
      tags: [dns]

    # =========================================================================
    # PHASE 1: FIREWALL CONFIGURATION
    # =========================================================================
    - name: Install firewall packages
      ansible.builtin.apt:
        name: [iptables, iptables-persistent, netfilter-persistent]
        state: present
        update_cache: true
      tags: [system, firewall]

    - name: Check if K3s is already running
      ansible.builtin.stat:
        path: /usr/local/bin/k3s
      register: k3s_pre_firewall
      tags: [system, firewall]

    - name: Flush iptables (Oracle defaults block K8s)
      ansible.builtin.iptables:
        chain: "{{ item.chain }}"
        table: "{{ item.table | default('filter') }}"
        flush: true
      loop:
        - { chain: INPUT }
        - { chain: FORWARD }
        - { chain: OUTPUT }
      notify: Save iptables
      tags: [system, firewall]

    - name: Set iptables default policy to ACCEPT
      ansible.builtin.iptables:
        chain: "{{ item }}"
        policy: ACCEPT
      loop: [INPUT, FORWARD, OUTPUT]
      notify: Save iptables
      tags: [system, firewall]

    - name: Flush handlers
      ansible.builtin.meta: flush_handlers
      tags: [system, firewall]

    - name: Restart K3s to rebuild iptables rules
      ansible.builtin.systemd:
        name: k3s
        state: restarted
      when: k3s_pre_firewall.stat.exists
      tags: [system, firewall]

    - name: Wait for K3s API after firewall changes
      ansible.builtin.wait_for:
        port: 6443
        host: 127.0.0.1
        delay: 5
        timeout: 120
      when: k3s_pre_firewall.stat.exists
      tags: [system, firewall]

    # =========================================================================
    # PHASE 2: SYSTEM PACKAGES
    # =========================================================================
    - name: Install required packages
      ansible.builtin.apt:
        name:
          - curl
          - wget
          - ca-certificates
          - gnupg
          - tar
          - gzip
          - open-iscsi
          - nfs-common
          - jq
          - git
        state: present
        update_cache: true
        cache_valid_time: 3600
      tags: [system]

    # =========================================================================
    # PHASE 3: K3S INSTALLATION
    # =========================================================================
    - name: Check if K3s installed
      ansible.builtin.stat:
        path: /usr/local/bin/k3s
      register: k3s_binary
      tags: [k3s]

    - name: Install K3s
      ansible.builtin.shell: |
        curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION="{{ k3s_version }}" sh -s - \
          --write-kubeconfig-mode 644 \
          --disable traefik \
          --tls-san {{ ansible_host }} \
          --tls-san {{ domain }} \
          --tls-san {{ api_subdomain }}.{{ domain }}
      when: not k3s_binary.stat.exists
      tags: [k3s]

    - name: Wait for K3s API
      ansible.builtin.wait_for:
        port: 6443
        host: 127.0.0.1
        delay: 5
        timeout: 300
      tags: [k3s]

    - name: Wait for node ready
      ansible.builtin.shell: kubectl wait --for=condition=Ready node --all --timeout=300s
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      retries: 5
      delay: 10
      register: node_ready
      until: node_ready.rc == 0
      changed_when: false
      tags: [k3s]

    # =========================================================================
    # PHASE 4: HELM INSTALLATION
    # =========================================================================
    - name: Check if Helm installed
      ansible.builtin.stat:
        path: /usr/local/bin/helm
      register: helm_binary
      tags: [helm]

    - name: Install Helm
      when: not helm_binary.stat.exists
      block:
        - name: Download Helm installer
          ansible.builtin.shell: |
            curl -4 -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 -o /tmp/get-helm-3.sh
            chmod 755 /tmp/get-helm-3.sh
          args:
            creates: /tmp/get-helm-3.sh

        - name: Run Helm installer
          ansible.builtin.shell: /tmp/get-helm-3.sh
      tags: [helm]

    # =========================================================================
    # PHASE 5: APPLY KUBERNETES MANIFESTS
    # =========================================================================
    - name: Create temp directory for manifests
      ansible.builtin.file:
        path: /tmp/k8s-manifests
        state: directory
        mode: "0755"
      tags: [k8s]

    - name: Copy K8s manifests to remote
      ansible.builtin.copy:
        src: "{{ k8s_manifests_dir }}/"
        dest: /tmp/k8s-manifests/
        mode: "0644"
      tags: [k8s]

    - name: Process manifest templates (domains and config)
      ansible.builtin.shell: |
        find /tmp/k8s-manifests -name "*.yaml" -exec sed -i \
          -e 's|\${DOMAIN}|{{ domain }}|g' \
          -e 's|\${API_SUBDOMAIN}|{{ api_subdomain }}|g' \
          -e 's|\${DEPLOY_WILDCARD}|{{ deploy_wildcard }}|g' \
          -e 's|\${LETSENCRYPT_EMAIL}|{{ letsencrypt_email }}|g' \
          -e 's|\${LETSENCRYPT_ISSUER}|{{ letsencrypt_issuer }}|g' \
          -e 's|\${NODE_TLS_REJECT_UNAUTHORIZED}|{{ node_tls_reject_unauthorized }}|g' \
          -e 's|\${REGISTRY_STORAGE_SIZE}|{{ registry_storage_size }}|g' \
          -e 's|\${REDIS_MEMORY_LIMIT}|{{ redis_memory_limit }}|g' \
          -e 's|\${WORKER_API_KEY}|{{ worker_api_key }}|g' \
          -e 's|\${SERVER_IP}|{{ ansible_host }}|g' \
          {} \;
      tags: [k8s]

    # Generate backend secrets from Jinja2 template
    - name: Generate backend secrets from template
      ansible.builtin.template:
        src: templates/backend-secrets.yaml.j2
        dest: /tmp/k8s-manifests/05-code2cloud/backend-secrets.yaml
        mode: "0600"
      tags: [k8s]
      no_log: true

    # Apply in order: namespaces â†’ cert-manager â†’ traefik â†’ registry â†’ apps
    - name: Apply namespaces
      ansible.builtin.shell: kubectl apply -f /tmp/k8s-manifests/00-namespaces/
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, namespaces]

    - name: Add Jetstack Helm repo (cert-manager)
      ansible.builtin.shell: |
        helm repo add jetstack https://charts.jetstack.io 2>/dev/null || true
        helm repo update
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, cert-manager]

    - name: Install cert-manager via Helm
      ansible.builtin.shell: |
        helm upgrade --install cert-manager jetstack/cert-manager \
          --namespace cert-manager \
          --create-namespace \
          --version {{ cert_manager_version }} \
          --set installCRDs=true \
          --set resources.requests.cpu=50m \
          --set resources.requests.memory=128Mi \
          --set webhook.resources.requests.cpu=50m \
          --set webhook.resources.requests.memory=128Mi \
          --set cainjector.resources.requests.cpu=50m \
          --set cainjector.resources.requests.memory=128Mi \
          --wait --timeout 10m
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, cert-manager]

    - name: Wait for cert-manager webhook
      ansible.builtin.shell: |
        kubectl wait --for=condition=Available deployment/cert-manager-webhook \
          -n cert-manager --timeout=120s
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, cert-manager]

    - name: Apply ClusterIssuers
      ansible.builtin.shell: kubectl apply -f /tmp/k8s-manifests/01-cert-manager/
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      retries: 3
      delay: 10
      register: issuer_result
      until: issuer_result.rc == 0
      tags: [k8s, cert-manager]

    - name: Add Traefik Helm repo
      ansible.builtin.shell: |
        helm repo add traefik https://traefik.github.io/charts 2>/dev/null || true
        helm repo update
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, traefik]

    - name: Install Traefik via Helm
      ansible.builtin.shell: |
        helm upgrade --install traefik traefik/traefik \
          --namespace traefik \
          --create-namespace \
          --version {{ traefik_chart_version }} \
          --values /tmp/k8s-manifests/02-traefik/values.yaml \
          --wait --timeout 5m
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, traefik]

    - name: Apply Traefik middleware
      ansible.builtin.shell: kubectl apply -f /tmp/k8s-manifests/02-traefik/middleware.yaml
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, traefik]

    - name: Apply Registry manifests
      ansible.builtin.shell: kubectl apply -f /tmp/k8s-manifests/03-registry/
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, registry]

    - name: Wait for Registry
      ansible.builtin.shell: |
        kubectl rollout status deployment/registry -n registry --timeout=120s
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, registry]

    - name: Configure K3s private registry
      block:
        - name: Get Registry ClusterIP
          ansible.builtin.shell: |
            kubectl get svc registry -n registry -o jsonpath='{.spec.clusterIP}'
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"
          register: registry_ip

        - name: Create registries.yaml
          ansible.builtin.copy:
            dest: /etc/rancher/k3s/registries.yaml
            content: |
              mirrors:
                "registry.registry.svc.cluster.local:5000":
                  endpoint:
                    - "http://{{ registry_ip.stdout }}:5000"
              configs:
                "{{ registry_ip.stdout }}:5000":
                  tls:
                    insecure_skip_verify: true
            mode: "0644"
          notify: Restart k3s
      tags: [k8s, registry]

    - name: Flush handlers (restart K3s if needed)
      ansible.builtin.meta: flush_handlers
      tags: [k8s, registry]

    - name: Wait for K3s after restart
      ansible.builtin.wait_for:
        port: 6443
        host: 127.0.0.1
        delay: 5
        timeout: 120
      tags: [k8s, registry]

    - name: Apply BuildKit manifests
      ansible.builtin.shell: kubectl apply -f /tmp/k8s-manifests/04-buildkit/
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, buildkit]

    - name: Wait for BuildKit to be ready
      ansible.builtin.shell: |
        kubectl rollout status deployment/buildkitd -n default --timeout=180s
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, buildkit]

    - name: Apply Code2Cloud platform manifests
      ansible.builtin.shell: kubectl apply -f /tmp/k8s-manifests/05-code2cloud/
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      tags: [k8s, code2cloud]

    # =========================================================================
    # PHASE 6: BUILD AND PUSH IMAGES
    # =========================================================================
    - name: Build and push application images
      block:
        - name: Create build workspace
          ansible.builtin.file:
            path: "{{ build_workspace }}"
            state: directory
            mode: "0755"

        - name: Clone Code2Cloud repository
          ansible.builtin.git:
            repo: "{{ git_repo_url }}"
            dest: "{{ build_workspace }}/repo"
            version: "{{ git_branch }}"
            force: true

        - name: Install Railpack
          ansible.builtin.shell: |
            curl -fsSL https://railpack.com/install.sh | bash
          args:
            creates: /usr/local/bin/railpack

        - name: Verify Railpack installation
          ansible.builtin.shell: |
            RAILPACK_PATH=$(which railpack 2>/dev/null || find /root /usr/local -name "railpack" -type f 2>/dev/null | head -1)
            if [ -z "$RAILPACK_PATH" ]; then
              ARCH=$(uname -m)
              case $ARCH in
                aarch64|arm64) ARCH="aarch64" ;;
                x86_64) ARCH="x86_64" ;;
              esac
              curl -fsSL "https://github.com/railwayapp/railpack/releases/latest/download/railpack-${ARCH}-unknown-linux-gnu.tar.gz" | tar -xz -C /usr/local/bin
              chmod +x /usr/local/bin/railpack
            fi
            railpack --version || /usr/local/bin/railpack --version
          register: railpack_verify

        - name: Display Railpack version
          ansible.builtin.debug:
            var: railpack_verify.stdout

        - name: Install buildctl CLI
          ansible.builtin.shell: |
            if ! command -v buildctl &> /dev/null; then
              ARCH=$(uname -m)
              case $ARCH in
                aarch64|arm64) ARCH="arm64" ;;
                x86_64) ARCH="amd64" ;;
              esac
              curl -fsSL "https://github.com/moby/buildkit/releases/download/v0.21.0/buildkit-v0.21.0.linux-${ARCH}.tar.gz" | tar -xz -C /usr/local bin/buildctl
              chmod +x /usr/local/bin/buildctl
            fi
            buildctl --version
          register: buildctl_install

        - name: Get BuildKit service IP
          ansible.builtin.shell: |
            kubectl get svc buildkitd -n default -o jsonpath='{.spec.clusterIP}'
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"
          register: buildkit_ip

        - name: Get Registry service IP
          ansible.builtin.shell: |
            kubectl get svc registry -n registry -o jsonpath='{.spec.clusterIP}'
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"
          register: registry_ip_build

        # =====================================================================
        # BUILD BACKEND (NestJS)
        # =====================================================================
        - name: Build and push backend image
          ansible.builtin.shell: |
            cd {{ build_workspace }}/repo
            buildctl --addr tcp://{{ buildkit_ip.stdout }}:1234 build \
              --frontend dockerfile.v0 \
              --local context=. \
              --local dockerfile=apps/api \
              --opt build-arg:DATABASE_URL={{ database_url }} \
              --opt build-arg:DATABASE_DIRECT_URL={{ database_direct_url }} \
              --output type=image,name={{ registry_ip_build.stdout }}:5000/code2cloud-backend:latest,push=true,registry.insecure=true
          environment:
            PATH: "/usr/local/bin:{{ ansible_env.PATH }}"
          register: backend_build
          delay: 60
          retries: 2
          until: backend_build.rc == 0

        - name: Display backend build result
          ansible.builtin.debug:
            msg: "Backend image built and pushed: {{ registry_ip_build.stdout }}:5000/code2cloud-backend:latest"

        # =====================================================================
        # BUILD FRONTEND (Next.js)
        # =====================================================================
        - name: Ensure public folder exists for frontend
          ansible.builtin.file:
            path: "{{ build_workspace }}/repo/apps/web/public"
            state: directory
            mode: "0755"

        - name: Build and push frontend image
          ansible.builtin.shell: |
            cd {{ build_workspace }}/repo
            buildctl --addr tcp://{{ buildkit_ip.stdout }}:1234 build \
              --frontend dockerfile.v0 \
              --local context=. \
              --local dockerfile=apps/web \
              --opt build-arg:NEXT_PUBLIC_API_URL=https://{{ api_subdomain }}.{{ domain }} \
              --opt build-arg:NEXT_PUBLIC_APP_URL=https://{{ domain }} \
              --output type=image,name={{ registry_ip_build.stdout }}:5000/code2cloud-frontend:latest,push=true,registry.insecure=true
          environment:
            PATH: "/usr/local/bin:{{ ansible_env.PATH }}"
          register: frontend_build
          delay: 60
          retries: 2
          until: frontend_build.rc == 0

        - name: Display frontend build result
          ansible.builtin.debug:
            msg: "Frontend image built and pushed: {{ registry_ip_build.stdout }}:5000/code2cloud-frontend:latest"

        # =====================================================================
        # BUILD WORKER (Go)
        # =====================================================================
        - name: Build and push worker image
          ansible.builtin.shell: |
            cd {{ build_workspace }}/repo
            buildctl --addr tcp://{{ buildkit_ip.stdout }}:1234 build \
              --frontend dockerfile.v0 \
              --local context=. \
              --local dockerfile=apps/worker \
              --output type=image,name={{ registry_ip_build.stdout }}:5000/code2cloud-worker:latest,push=true,registry.insecure=true
          environment:
            PATH: "/usr/local/bin:{{ ansible_env.PATH }}"
          register: worker_build
          delay: 60
          retries: 2
          until: worker_build.rc == 0

        - name: Display worker build result
          ansible.builtin.debug:
            msg: "Worker image built and pushed: {{ registry_ip_build.stdout }}:5000/code2cloud-worker:latest"

        # =====================================================================
        # RESTART DEPLOYMENTS
        # =====================================================================
        - name: Restart backend deployment
          ansible.builtin.shell: |
            kubectl rollout restart deployment/backend -n code2cloud
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"

        - name: Restart frontend deployment
          ansible.builtin.shell: |
            kubectl rollout restart deployment/frontend -n code2cloud
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"

        - name: Restart worker deployment
          ansible.builtin.shell: |
            kubectl rollout restart deployment/worker -n code2cloud
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"

        - name: Wait for backend rollout
          ansible.builtin.shell: |
            kubectl rollout status deployment/backend -n code2cloud --timeout=300s
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"

        - name: Wait for frontend rollout
          ansible.builtin.shell: |
            kubectl rollout status deployment/frontend -n code2cloud --timeout=300s
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"

        - name: Wait for worker rollout
          ansible.builtin.shell: |
            kubectl rollout status deployment/worker -n code2cloud --timeout=300s
          environment:
            KUBECONFIG: "{{ kubeconfig_remote }}"

        - name: Cleanup build workspace
          ansible.builtin.file:
            path: "{{ build_workspace }}"
            state: absent
      tags: [build]

    # =========================================================================
    # PHASE 7: FETCH KUBECONFIG
    # =========================================================================
    - name: Remove stale Kubeconfig on Local Machine
      delegate_to: localhost
      become: false
      ansible.builtin.file:
        path: "{{ kubeconfig_dir }}"
        state: absent
      tags: [kubeconfig]

    - name: Fetch kubeconfig
      ansible.builtin.fetch:
        src: "{{ kubeconfig_remote }}"
        dest: "{{ kubeconfig_dir }}"
        flat: true
      become: true
      tags: [kubeconfig]

    - name: Update kubeconfig server URL
      delegate_to: localhost
      become: false
      ansible.builtin.replace:
        path: "{{ kubeconfig_dir }}"
        regexp: 'server: https://.*:6443'
        replace: 'server: https://{{ ansible_host }}:6443'
      tags: [kubeconfig]

    - name: Copy kubeconfig to Windows home for Powershell
      delegate_to: localhost
      become: false
      ansible.builtin.shell: cp "{{ kubeconfig_dir }}" "/mnt/c/Users/Lakshman/.kube/config"
      tags: [kubeconfig]

    # =========================================================================
    # PHASE 8: VERIFICATION
    # =========================================================================
    - name: Show cluster status
      ansible.builtin.shell: |
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "NODES:"
        kubectl get nodes -o wide
        echo ""
        echo "NAMESPACES:"
        kubectl get ns
        echo ""
        echo "ALL PODS:"
        kubectl get pods -A
        echo ""
        echo "SERVICES:"
        kubectl get svc -A
        echo ""
        echo "INGRESSES:"
        kubectl get ingress -A
        echo ""
        echo "CERTIFICATES:"
        kubectl get certificates -A
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
      environment:
        KUBECONFIG: "{{ kubeconfig_remote }}"
      register: cluster_status
      changed_when: false
      tags: [verify]

    - name: Display status
      ansible.builtin.debug:
        var: cluster_status.stdout_lines
      tags: [verify]

    - name: Setup complete
      ansible.builtin.pause:
        seconds: 1
        prompt: |
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    CODE2CLOUD INFRASTRUCTURE READY!
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          ğŸŒ Endpoints:
            Frontend:  https://{{ domain }}
            API:       https://{{ api_subdomain }}.{{ domain }}
            User Apps: https://*.{{ deploy_wildcard }}.{{ domain }}
          
          ğŸ”‘ Kubernetes API: https://{{ ansible_host }}:6443
          ğŸ“ Kubeconfig:     {{ kubeconfig_local }}
          
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          TEST COMMANDS:
            export KUBECONFIG={{ kubeconfig_local }}
            kubectl get nodes
            kubectl get pods -n code2cloud
            kubectl logs -f deployment/worker -n code2cloud
          
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      tags: [always]